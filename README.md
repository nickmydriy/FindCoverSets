# Взвешенная задача о покрытии множеств.

### Постановка задачи.

Пусть имеется конечное множество $$S = (\sigma1, \sigma2, ..., \sigma_m)$$ и система его подмножеств $$S_j \subset S, j = 1, 2, ... ,n$$, такие что
$$\cup{S_j} = S$$.
Каждому из подмножеств $$S_j$$ поставлен в соответствие вес $$c_j > 0$$,
таким образом рассматривается задача о взвешенном покрытии. Требуется
найти минимальный по числу подмножеств набор $$S_j$$, такой, что каждый
элемент множества принадлежит хотя бы одному из подмножеств этого набора.

### Решение с помощью генетического алгоритма.

Определим генетический алгоритм следующим образом:  
1. Выбираем начальную популяцию.  
2. Выбираем несколько пар родительских особей.
3. Применяем генетический оператор скрещивания для каждой пары родительских особей.  
4. Применяем генетический оператор мутации для всех получившихся в результате скрещивания особей.
5. Замена новыми особями популяции.
6. Повторяем шаги 1-5 пока не достигнем результата.

### Представление особи в генетическом алгоритме для решения взвешенной задачи о покрытии.

Будем представлять особь в виде n-мерного вектора $$X$$. Где каждый элемент 
$$\inline X_j$$ будет 0 или 1. В случае если $$X_j=1$$, подмножество $$S_j$$ входит в покрытие, иначе нет.

### Представление системы подмножеств.

Подмножества будем хранить в виде матрицы $$\inline R_{nxm}$$ , где каждый элемент $$\inline R_{i,j} \in {0,1}$$. Если $$\inline R_{i,j}=1$$ значит $$\inline \sigma_j \in S_i$$ , иначе $$\inline \sigma_j \notin S_i$$.

## План работы.

###  Необходимые генетические операторы и вспомогательные функции.

Для работы генетического алгоритма нам будут необходимы некоторые описанные ниже функции.

Генетический операторы:

1. Функция для получения особи. Необходима для построения начальной популяции. Должна случайно генерировать особь. (возможно не совсем случайно, а опираясь на какие-либо данные)
2. Функция селекции. Необходима для выбора родительских пар. Должна генерировать список родительских пар. 
3. Функция скрещивания. Необходима для скрещивания особей и получения новых индивидов. По заданной паре особей должна генерировать новую особь (или особей).
4. Функция мутирования. Необходима для мутации особей. По заданной особи должна генерировать новую особь.
5. Функция смены популяции. Необходима для осуществления механизма замены старого поколения новым. По заданной новой особи и списку из особей (популяция) должна произвести замену одной старой особи на заданную новую  (может и не заменить, если новая особь "плохая").

Вспомогательные функции:

1. Функция приспособленности. Определяет насколько хорошо индивид показывает себя. В данном случае функция приспособленности будет везде одна. И это будет сумма весов всех подмножеств, которые описывает индивид. Чем меньше значение этой функции, тем особь лучше.
2. Функция восстановления. Может получиться так, что в результате применения функций для получения особи, скрещивания и мутирования мы получим особь, которая не задет покрытие множества. Нам необходима функция, которая дополнит ее множествами $$S_j$$ до покрытия.
3. Функция проверки на покрытие. (В целом не думаю, что данная функция будет меняться на протяжении проекта, но все же вынес ее за пределы алгоритма).

### Идеи работы.

Во многом эффективность работы генетического алгоритма зависит от выбора начальной популяции и генетических операторов (скрещивание, мутация итд.). И именно выбор этих функций определяет насколько "хороший" результат мы получим. 
В данной задаче так-же влияет еще и выбор вспомогательных функций (функция восстановления). Так, например, результат функции восстановления может быть локальным экстремумом задачи. Что в целом дает довольно хорошую начальную популяцию, так и новые генерируемые новые поколения.

Есть много разных способов реализации этих функций, и каждая из них "хороша" по-своему, в зависимости от конкретной задачи.

### Цель работы

Исследовать эффективность применения различных функций (генетических операторов, вспомогательных функций) в генетическом алгоритме, для взвешенной задачи о минимальном покрытии. 

## Рабочий процесс

### План работы
1. (выполнено) Написать каркас для генетического алгоритма. (без реализации функций)
2. (выполнено) Написать простые реализации функций. Проверить корректность работы алгоритма.
3. (выполнено*) Написать тесты для оценки эффективности работы алгоритма. 
4. Написать более "умные" реализации функций. Исследовать их на эффективность. Сохранить результаты. (данный этап основной в ходе работы, проделываем его для нескольких наборов функций)
5. По сохраненным результатам подвести итоги. (сравнить эффективность использования различных наборов функций, сделать выводы)

### Оценка эффективности

Для оценки эффективности будем использовать 2(3) группы тестов:

#### 1. Оценка точности.
Первая группа тестов будет направлена на проверку точности алгоритма на небольших входных данных. (для которых мы можем найти точный ответ) В данных тестах будем генерировать матрицу размером nxn (n < 25) и массив размерности n(цены множеств, заполнение случайными числами в диапазоне [0..100]). Высчитывать точный ответ методом полного перебора. Далее несколько раз(~5) будем запускать генетический алгоритм от этой матрицы. После этого делаем сравнение ответов, полученных генетическим алгоритмом и точного ответа.

Эти тесты покажут нам, как часто алгоритм не доходит до глобального экстремума задачи и останавливается в каком-то локальном экстремуме, так-же они покажут насколько сильно отличается полученный результат от точного. 

Для данной группы тестов оценкой эффективности будет среднее процентное отклонение от решения полученного алгоритмом полного перебора и процент достигших глобального экстремума.

#### 2. Оценка устойчивости.
Вторая группа тестов направлена на проверку устойчивости алгоритма на более больших данных. В данных тестах будем генерировать матрицу размером nxn (n < 200) и массив размерности n(цены множеств, заполнение случайными числами в диапазоне [0..100]). Для каждой матрицы несколько раз(~20) будем запускать генетический алгоритм. После этого находим минимальный и максимальный ответ.

Эти тесты покажут нам, как сильно отличаются результаты для одних входных данных, и насколько устойчив алгоритм. 

Для данной группы тестов оценкой эффективности будет среднее процентное отклонение полученного максимума от минимума.

Таким образом чем ниже значение отклонения тем более устойчив алгоритм.

#### 3. Тесты из библиотеки  OR Library.
Хоть они содержат не случайные задачи, а более конкретные (а оценка эффективности в таком случае может быть неверной в решении абстрактной задачи), но все же стоит проверить эффективность и на этих тестах. Так как, если на этих тестах решение будет не эффективным, то и на решении абстрактной задачи оно будет не эффективном. 

## Ссылки на используемый материал.
1. Нгуен Минь Ханг, Применение генетического алгоритма для задачи нахождения покрытия множества. [ссылка](http://www.isa.ru/proceedings/images/documents/2008-33/206-219.pdf)
2. Т.В. Панченко, Генетические алгоритмы [ссылка](http://mathmod.asu.edu.ru/images/File/ebooks/GAfinal.pdf)
3. И.С. Коновалов, В.А. Фатхи, В.Г. Кобак, Применение генетического алгоритма для решения задачи покрытия множеств. [ссылка](http://naukaru.ru/app/uploads/docs/2016-10-14/c7ab4b9418671313a3df73836dd2fb50.pdf)
